{% load static %}

<script>
document.addEventListener('DOMContentLoaded', function() {
    const openBtn = document.getElementById('btn-open-metronome');
    const startStopBtn = document.getElementById('start-stop-btn');
    if (!startStopBtn) return;

    // Variáveis e referências
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const bpmInput = document.getElementById('bpm-input');
    const bpmSlider = document.getElementById('bpm-slider');
    const subdivisionControls = document.getElementById('subdivision-controls');
    const timerMinutesInput = document.getElementById('timer-minutes');
    const timerSecondsInput = document.getElementById('timer-seconds');
    const timerDisplay = document.getElementById('timer-display');

    let isPlaying = false;
    let bpm = parseInt(bpmInput.value, 10);
    let subdivision = 1;
    let countdownTimerId = null;
    let timeRemaining = 0;

    // NOVAS VARIÁVEIS PARA SCHEDULER PRECISO
    let nextNoteTime = 0;         // próximo tempo (s) no AudioContext
    let lookahead = 25.0;         // frequência de checagem (ms)
    let scheduleAheadTime = 0.1;  // quanto tempo à frente agendar (s)
    let schedulerInterval = null;

    // Sons
    const sounds = { accent: null, sub: null };
    async function loadSound(url) {
        const response = await fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        return await audioContext.decodeAudioData(arrayBuffer);
    }
    Promise.all([
        loadSound("{% static 'scheduler/sounds/clave-accent.wav' %}"),
        loadSound("{% static 'scheduler/sounds/clave-sub.wav' %}")
    ]).then(([accentBuffer, subBuffer]) => {
        sounds.accent = accentBuffer;
        sounds.sub = subBuffer;
        startStopBtn.disabled = false;
        startStopBtn.innerHTML = '<i class="bi bi-play-fill"></i> Iniciar';
    });
    startStopBtn.disabled = true;
    startStopBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> Carregando...';

    // Função para tocar o tick
    function playTick(isAccent, time) {
        if (!sounds.accent || !sounds.sub) return;
        const source = audioContext.createBufferSource();
        source.buffer = isAccent ? sounds.accent : sounds.sub;
        source.connect(audioContext.destination);
        source.start(time);

        // animação no botão no momento da batida principal
        if (isAccent) {
            setTimeout(() => {
                openBtn.classList.add('is-pulsing');
                setTimeout(() => openBtn.classList.remove('is-pulsing'), 200);
            }, (time - audioContext.currentTime) * 1000);
        }
    }

    // Agenda as notas com precisão
    function scheduler() {
        while (nextNoteTime < audioContext.currentTime + scheduleAheadTime) {
            // Batida principal
            playTick(true, nextNoteTime);

            // Subdivisões
            if (subdivision > 1) {
                const subdivisionInterval = (60 / bpm) / subdivision;
                for (let i = 1; i < subdivision; i++) {
                    playTick(false, nextNoteTime + (i * subdivisionInterval));
                }
            }
            nextNote();
        }
    }

    // Calcula o tempo da próxima batida
    function nextNote() {
        const secondsPerBeat = 60.0 / bpm;
        nextNoteTime += secondsPerBeat;
    }

    function startMetronome() {
        nextNoteTime = audioContext.currentTime + 0.05; // pequeno atraso inicial
        schedulerInterval = setInterval(scheduler, lookahead);
    }

    function stopMetronome() {
        clearInterval(schedulerInterval);
        schedulerInterval = null;
    }

    // Temporizador
    function updateTimerDisplay() {
        const minutes = Math.floor(timeRemaining / 60).toString().padStart(2, '0');
        const seconds = (timeRemaining % 60).toString().padStart(2, '0');
        timerDisplay.textContent = `${minutes}:${seconds}`;
    }
    function startTimer() {
        const minutes = parseInt(timerMinutesInput.value, 10) || 0;
        const seconds = parseInt(timerSecondsInput.value, 10) || 0;
        timeRemaining = (minutes * 60) + seconds;
        if (timeRemaining <= 0) return;
        updateTimerDisplay();
        countdownTimerId = setInterval(() => {
            timeRemaining--;
            updateTimerDisplay();
            if (timeRemaining <= 0) stopAll();
        }, 1000);
    }
    function updateTimerDisplayFromInputs() {
        const minutes = parseInt(timerMinutesInput.value, 10) || 0;
        const seconds = parseInt(timerSecondsInput.value, 10) || 0;
        timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    // Parar tudo
    function stopAll() {
        isPlaying = false;
        stopMetronome();
        clearInterval(countdownTimerId);
        countdownTimerId = null;
        startStopBtn.innerHTML = '<i class="bi bi-play-fill"></i> Iniciar';
        startStopBtn.classList.replace('btn-danger', 'btn-primary');
        updateTimerDisplayFromInputs();
        if (openBtn) openBtn.classList.remove('is-active');
    }

    // Evento principal play/stop
    startStopBtn.addEventListener('click', () => {
        if (audioContext.state === 'suspended') audioContext.resume();
        isPlaying = !isPlaying;
        if (isPlaying) {
            startStopBtn.innerHTML = '<i class="bi bi-stop-fill"></i> Parar';
            startStopBtn.classList.replace('btn-primary', 'btn-danger');
            startMetronome();
            startTimer();
            if (openBtn) openBtn.classList.add('is-active');
        } else {
            stopAll();
        }
    });

    // Controles de BPM
    function updateBPM() {
        bpmSlider.value = bpmInput.value;
        bpm = parseInt(bpmInput.value, 10);
    }
    function updateBPMSlider() {
        bpmInput.value = bpmSlider.value;
        bpm = parseInt(bpmSlider.value, 10);
    }
    bpmInput.addEventListener('change', updateBPM);
    bpmSlider.addEventListener('change', updateBPMSlider);
    bpmInput.addEventListener('input', () => bpmSlider.value = bpmInput.value);
    bpmSlider.addEventListener('input', () => bpmInput.value = bpmSlider.value);

    document.getElementById('bpm-minus-10').addEventListener('click', () => {
        bpmInput.value = Math.max(40, parseInt(bpmInput.value) - 10);
        updateBPM();
    });
    document.getElementById('bpm-minus-5').addEventListener('click', () => {
        bpmInput.value = Math.max(40, parseInt(bpmInput.value) - 5);
        updateBPM();
    });
    document.getElementById('bpm-plus-5').addEventListener('click', () => {
        bpmInput.value = Math.min(240, parseInt(bpmInput.value) + 5);
        updateBPM();
    });
    document.getElementById('bpm-plus-10').addEventListener('click', () => {
        bpmInput.value = Math.min(240, parseInt(bpmInput.value) + 10);
        updateBPM();
    });

    // Subdivisões
    subdivisionControls.addEventListener('change', (event) => {
        if (event.target.name === 'subdivision') {
            subdivision = parseInt(event.target.value, 10);
        }
    });

    // Timer inputs
    timerMinutesInput.addEventListener('input', updateTimerDisplayFromInputs);
    timerSecondsInput.addEventListener('input', updateTimerDisplayFromInputs);
});
</script>
