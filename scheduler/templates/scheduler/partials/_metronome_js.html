{% load static %}

<script>
document.addEventListener('DOMContentLoaded', function() {
    const openBtn = document.getElementById('btn-open-metronome');
    const startStopBtn = document.getElementById('start-stop-btn');
    if (!startStopBtn) return;

    // --- Referências de Elementos ---
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const bpmDisplayVal = document.getElementById('bpm-display-val'); // Texto grande
    const bpmSlider = document.getElementById('bpm-slider');
    const subdivisionControls = document.getElementById('subdivision-controls');
    const timerMinutesInput = document.getElementById('timer-minutes');
    const timerSecondsInput = document.getElementById('timer-seconds');
    const timerDisplay = document.getElementById('timer-display');
    const visualLight = document.getElementById('visual-beat-light'); // Luzinha
    const tapBtn = document.getElementById('tap-tempo-btn');

    // --- Estado ---
    let isPlaying = false;
    let bpm = 120;
    let subdivision = 1;
    let countdownTimerId = null;
    let timeRemaining = 0;

    // --- Scheduler Audio ---
    let nextNoteTime = 0;
    let lookahead = 25.0;
    let scheduleAheadTime = 0.1;
    let schedulerInterval = null;

    // --- Carregamento de Sons ---
    const sounds = { accent: null, sub: null };
    async function loadSound(url) {
        const response = await fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        return await audioContext.decodeAudioData(arrayBuffer);
    }
    
    // Ajuste os caminhos conforme sua estrutura de static
    Promise.all([
        loadSound("{% static 'scheduler/sounds/clave-accent.wav' %}"),
        loadSound("{% static 'scheduler/sounds/clave-sub.wav' %}")
    ]).then(([accentBuffer, subBuffer]) => {
        sounds.accent = accentBuffer;
        sounds.sub = subBuffer;
        startStopBtn.disabled = false;
    }).catch(err => console.error("Erro ao carregar sons:", err));

    // --- Motor de Áudio ---
    function playTick(isAccent, time) {
        if (!sounds.accent || !sounds.sub) return;
        
        // Som
        const source = audioContext.createBufferSource();
        source.buffer = isAccent ? sounds.accent : sounds.sub;
        source.connect(audioContext.destination);
        source.start(time);

        // Visual (Sincronizado com o tempo)
        // Usamos setTimeout baseado na diferença de tempo para ser visualmente preciso
        const drawTime = (time - audioContext.currentTime) * 1000;
        setTimeout(() => {
            if (isAccent) {
                // Flash na luz do modal
                if(visualLight) {
                    visualLight.classList.add('active');
                    setTimeout(() => visualLight.classList.remove('active'), 100);
                }
                // Pulso no botão flutuante principal (se existir)
                if(openBtn) {
                    openBtn.classList.add('is-pulsing');
                    setTimeout(() => openBtn.classList.remove('is-pulsing'), 200);
                }
            } else {
                // Flash mais fraco para subdivisão (opcional)
                if(visualLight) {
                    visualLight.style.backgroundColor = 'var(--bs-border-color)';
                    setTimeout(() => visualLight.style.backgroundColor = '', 50);
                }
            }
        }, drawTime);
    }

    function scheduler() {
        while (nextNoteTime < audioContext.currentTime + scheduleAheadTime) {
            playTick(true, nextNoteTime); // Batida principal

            if (subdivision > 1) {
                const subdivisionInterval = (60 / bpm) / subdivision;
                for (let i = 1; i < subdivision; i++) {
                    playTick(false, nextNoteTime + (i * subdivisionInterval));
                }
            }
            nextNote();
        }
    }

    function nextNote() {
        const secondsPerBeat = 60.0 / bpm;
        nextNoteTime += secondsPerBeat;
    }

    function startMetronome() {
        if (audioContext.state === 'suspended') audioContext.resume();
        nextNoteTime = audioContext.currentTime + 0.05;
        schedulerInterval = setInterval(scheduler, lookahead);
    }

    function stopMetronome() {
        clearInterval(schedulerInterval);
        schedulerInterval = null;
    }

    // --- Timer ---
    function updateTimerDisplayText() {
        const minutes = Math.floor(timeRemaining / 60).toString().padStart(2, '0');
        const seconds = (timeRemaining % 60).toString().padStart(2, '0');
        timerDisplay.textContent = `${minutes}:${seconds}`;
    }

    function startTimer() {
        const m = parseInt(timerMinutesInput.value, 10) || 0;
        const s = parseInt(timerSecondsInput.value, 10) || 0;
        timeRemaining = (m * 60) + s;
        
        if (timeRemaining <= 0) return; // Se for 0, roda infinito
        
        updateTimerDisplayText();
        countdownTimerId = setInterval(() => {
            timeRemaining--;
            updateTimerDisplayText();
            if (timeRemaining <= 0) stopAll();
        }, 1000);
    }

    // --- Controles de UI ---
    function stopAll() {
        isPlaying = false;
        stopMetronome();
        if (countdownTimerId) clearInterval(countdownTimerId);
        startStopBtn.innerHTML = '<i class="bi bi-play-fill me-2 fs-5"></i> INICIAR';
        startStopBtn.classList.replace('btn-danger', 'btn-primary');
        startStopBtn.classList.remove('pulse-animation'); // Se tiver animação CSS
    }

    startStopBtn.addEventListener('click', () => {
        isPlaying = !isPlaying;
        if (isPlaying) {
            startStopBtn.innerHTML = '<i class="bi bi-stop-fill me-2 fs-5"></i> PARAR';
            startStopBtn.classList.replace('btn-primary', 'btn-danger');
            startMetronome();
            startTimer();
        } else {
            stopAll();
        }
    });

    // --- Lógica de BPM ---
    function setBPM(val) {
        bpm = Math.min(240, Math.max(40, parseInt(val)));
        bpmDisplayVal.textContent = bpm;
        bpmSlider.value = bpm;
    }

    bpmSlider.addEventListener('input', (e) => {
        setBPM(e.target.value);
    });

    // Botões de incremento/decremento
    document.getElementById('bpm-minus-1').addEventListener('click', () => setBPM(bpm - 1));
    document.getElementById('bpm-plus-1').addEventListener('click', () => setBPM(bpm + 1));
    document.getElementById('bpm-minus-5').addEventListener('click', () => setBPM(bpm - 5));
    document.getElementById('bpm-plus-5').addEventListener('click', () => setBPM(bpm + 5));

    // --- Lógica TAP TEMPO ---
    let tapTimes = [];
    if(tapBtn) {
        tapBtn.addEventListener('click', (e) => {
            e.preventDefault(); // Evita foco estranho
            
            // Efeito visual no botão
            tapBtn.style.transform = 'scale(0.95)';
            setTimeout(() => tapBtn.style.transform = 'scale(1)', 100);

            const now = Date.now();
            
            // Se o último tap foi há mais de 2 segundos, reseta
            if (tapTimes.length > 0 && now - tapTimes[tapTimes.length - 1] > 2000) {
                tapTimes = [];
            }

            tapTimes.push(now);

            // Mantém apenas os últimos 4 taps para média
            if (tapTimes.length > 4) tapTimes.shift();

            if (tapTimes.length >= 2) {
                // Calcula as diferenças
                let intervals = [];
                for (let i = 1; i < tapTimes.length; i++) {
                    intervals.push(tapTimes[i] - tapTimes[i - 1]);
                }
                
                // Média dos intervalos
                const avgInterval = intervals.reduce((a, b) => a + b) / intervals.length;
                
                // Converte ms para BPM
                let newBpm = Math.round(60000 / avgInterval);
                setBPM(newBpm);
            }
        });
    }

    // --- Subdivisões ---
    subdivisionControls.addEventListener('change', (e) => {
        if (e.target.name === 'subdivision') {
            subdivision = parseInt(e.target.value, 10);
        }
    });
    
    // Atualiza display do timer se digitar nos inputs
    function formatInput(input) {
        let val = parseInt(input.value);
        if(isNaN(val)) val = 0;
        return val.toString().padStart(2, '0');
    }
    const updateTimerUI = () => {
        timerDisplay.textContent = `${formatInput(timerMinutesInput)}:${formatInput(timerSecondsInput)}`;
    };
    timerMinutesInput.addEventListener('change', updateTimerUI);
    timerSecondsInput.addEventListener('change', updateTimerUI);
});
</script>